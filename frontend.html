<!DOCTYPE html>
<html>
    <head>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
        <script>

            // Address of the Onchain Marketplace contract, set automatically by the constructor during contract creation
            const contractAddress = '0x9CC904561904B1B206069FE6d20995A0964f29ce';

            // Function to send requests to the user's wallet
            const request = (method, params) => window.ethereum.request({ method, params });

            // Functions to query and adjust page content during user/wallet interactions
            const getHtml = (id) => document.getElementById(id);
            const setHtml = (id, html) => document.getElementById(id).innerHTML = html;
            const createHtml = (tag) => document.createElement(tag);

            // Function to convert to hex number in string format
            const toHex = (num) => BigInt(num).toString(16);

            
            // Connect to a user's wallet, fetch the orders for sale in the collection and display them on the page, triggered by the 'Load collection' button
            function connect() {

                // Connect to the user's wallet
                request('eth_requestAccounts')
                .then((accounts) => {
                    setHtml('walletAddress', accounts[0]);
                    setHtml('welcome', 'Welcome ');
                })
                .catch((error) => {
                    setHtml('walletAddress', error); // change to display error message in a more appropriate place
                });

                // Switch wallet to Goerli
                request('wallet_switchEthereumChain', [{ chainId: '0x5' }]);

                // Check if the user is connected to Goerli
                request('net_version')
                .then((result) => {
                    if (result != 5) {
                        setHtml('network', 'Please connect to the Goerli test network before you continue.');      
                    }
                })

                // Get the collection address to display
                const token = (getHtml('tokenAddress').value.slice(2) || 'a29926934846fbf1000b5bce7a309a89dfb6f05a');

                // Display loading message and select the parent element of all collection item
                setHtml('forSale', 'Loading...');
                const container = getHtml('forSale');

                // Get the list of tokens for sale in the collection and display them
                request('eth_call',[{ to: contractAddress, data:'0x093376fe000000000000000000000000'+token }, 'latest'])
                .then((result) => {    
                    container.innerHTML = '';
                    const countClean = parseInt(result.substring(66,130), 10);
                    const ids = [];
                    for(let i = 0; i < countClean; i++) {
                        const id = result.substring(130 + i * 64, 130 + (i + 1) * 64);
                        const idClean = Number(parseInt(id, 16));
                        ids.push(idClean);    
                        const data = '0x793b8c6d000000000000000000000000'+token+id;
                        request('eth_call',[{ to: contractAddress, data:data }, 'latest'])
                        .then((result) => {
                            const endTime = Number(parseInt(result.substring(130,194), 16));
                            const endTimeDate = new Date(endTime * 1000);
                            if(result.substring(2,66) != '0'.repeat(64) && endTime > new Date().getTime()/1000) {
                                const newItem = createHtml('div');
                                newItem.id = idClean;
                                newItem.style = 'border: 1px solid black; padding: 1vh; margin-right: 1vh; margin-top:1vh;';
                                container.appendChild(newItem);
                                newItem.innerHTML = `<p>token no.</p><h3>${idClean}</h3><p>for sale until ${endTimeDate.toLocaleDateString()}</p>`;
                                const buyButton = createHtml('button');
                                const price = result.substring(2,66);
                                const priceClean = (Number(parseInt(price, 16))/1e5).toFixed(2);
                                const priceWei = toHex(priceClean*1e18);
                                const priceWei32 = "0".repeat(64-priceWei.length)+priceWei;
                                buyButton.innerHTML = 'Buy now Ξ'+priceClean;
                                const account = getHtml('walletAddress').innerHTML.slice(2);
                                buyButton.onclick = () => {
                                    buy('0x'+priceWei32, token, id, account); 
                                }; 
                                newItem.appendChild(buyButton);
                            }
                        })
                    }
                    getHtml('sell').style = 'display: block;';
                })
            }

            // Check if the token for sale is approved for Seaport, if not approve it for Seaport. Then create and sign an order for the token and send it to the Onchain Marketplace contract.
            async function sign(walletAddress,tokenAddress,tokenId,priceWei,startTime,endTime,salt) {

                const seaportAddress = '0x00000000000001ad428e4906aE43D8F9852d0dD6'.slice(2)
                
                // Check if the token is approved for Seaport
                const tokenIdBigInt = BigInt(tokenId).toString(16);
                const idCalldata = '0'.repeat(64-tokenIdBigInt.length)+tokenIdBigInt;
                const calldata = '0x081812fc'+idCalldata;
                const result = await request('eth_call',[{ from: walletAddress, to: tokenAddress, data:calldata }, 'latest'])

                // If not, approve it for Seaport
                if(result.slice(-40) != seaportAddress.toLowerCase()) {
                    const calldata2 = '0x095ea7b3'+'0'.repeat(64-seaportAddress.length)+seaportAddress+idCalldata;
                    await request('eth_sendTransaction',[{ from: walletAddress, to: tokenAddress, data:calldata2 }])
                }
                
                // Order structure for EIP712 signing 
                const msgParams = JSON.stringify({
                    'types': {
                        'EIP712Domain': [
                            { 'name': 'name', 'type': 'string' },
                            { 'name': 'version', 'type': 'string' },
                            { 'name': 'chainId', 'type': 'uint256' },
                            { 'name': 'verifyingContract', 'type': 'address' }
                        ],
                        'OrderComponents': [
                            { 'name': 'offerer', 'type': 'address' },
                            { 'name': 'zone', 'type': 'address' },
                            { 'name': 'offer', 'type': 'OfferItem[]' },
                            { 'name': 'consideration', 'type': 'ConsiderationItem[]' },
                            { 'name': 'orderType', 'type': 'uint8' },
                            { 'name': 'startTime', 'type': 'uint256' },
                            { 'name': 'endTime', 'type': 'uint256' },
                            { 'name': 'zoneHash', 'type': 'bytes32' },
                            { 'name': 'salt', 'type': 'uint256' },
                            { 'name': 'conduitKey', 'type': 'bytes32' },
                            { 'name': 'counter', 'type': 'uint256' }
                        ],
                        'OfferItem': [
                            { 'name': 'itemType', 'type': 'uint8' },
                            { 'name': 'token', 'type': 'address' },
                            { 'name': 'identifierOrCriteria', 'type': 'uint256' },
                            { 'name': 'startAmount', 'type': 'uint256' },
                            { 'name': 'endAmount', 'type': 'uint256' }
                        ],
                        'ConsiderationItem': [
                            { 'name': 'itemType', 'type': 'uint8' },
                            { 'name': 'token', 'type': 'address' },
                            { 'name': 'identifierOrCriteria', 'type': 'uint256' },
                            { 'name': 'startAmount', 'type': 'uint256' },
                            { 'name': 'endAmount', 'type': 'uint256' },
                            { 'name': 'recipient', 'type': 'address' }
                        ]
                    },
                    'primaryType': 'OrderComponents',
                    'domain': {
                        'name': 'Seaport',
                        'version': '1.4',
                        'chainId': '5',
                        'verifyingContract': '0x00000000000001ad428e4906aE43D8F9852d0dD6'
                    },
                    'message': {
                        'offerer': walletAddress,
                        'offer': [
                            {
                                'itemType': '2',
                                'token': tokenAddress,
                                'identifierOrCriteria': String(tokenId),
                                'startAmount': '1',
                                'endAmount': '1'
                            }
                        ],
                        'consideration': [
                            {
                                'itemType': '0',
                                'token': '0x0000000000000000000000000000000000000000',
                                'identifierOrCriteria': '0',
                                'startAmount': String(priceWei),
                                'endAmount': String(priceWei),
                                'recipient': walletAddress
                            }
                        ],
                        'orderType': '0',
                        'startTime': String(startTime),
                        'endTime': String(endTime),
                        'zone': contractAddress,
                        'zoneHash': '0x0000000000000000000000000000000000000000000000000000000000000000',
                        'salt': String(salt),
                        'conduitKey': '0x0000000000000000000000000000000000000000000000000000000000000000',
                        'counter': '0' // to be queried from the seaport contract in subsequent versions, means identical cancelled orders cannot be resubmitted currently
                    }
                });  
                
                // Sign the sell order
                const signature = await request( 'eth_signTypedData_v4', [ walletAddress, msgParams ] );
                return signature;
            }

            // Full sell process, triggered when the 'Sell' button is pressed
            async function sell() {

                // Get the sell order parameters
                const walletAddress = getHtml('walletAddress').textContent;
                const tokenAddress = getHtml('tokenAddress').value;
                const tokenId = getHtml('tokenId').value;
                const price = getHtml('price').value;
                const duration = getHtml('duration').value;

                // Convert the parameters to the correct format
                const priceWei = price * 1e18;
                const durationSeconds = duration * 86400;
                const startTime = Math.floor(Date.now() / 1000);
                const endTime = Math.floor(Date.now() / 1000) + durationSeconds;
                const salt = Math.floor(Math.random()*64999);
                const startTimeBigInt = toHex(startTime);
                const endTimeBigInt = toHex(endTime);
                const saltBigInt = toHex(salt);
                const priceWeiBigInt = toHex(priceWei);
                const tokenIdBigInt = toHex(tokenId);

                // Get the sell order signature
                const signature = await sign(walletAddress,tokenAddress,tokenId,priceWei,startTime,endTime,salt);
                
                // 32 bytes of zero and one, to compose the calldata
                const zero = '0'.repeat(64);
                const one = '0'.repeat(63)+'1';

                // Compose the calldata (each segment is 32 bytes)
                const calldataSegments = [
                    '0x59ce0ec5',
                    '0'.repeat(62)+'20',
                    '0'.repeat(62)+'40',
                    '0'.repeat(61)+'340',
                    '0'.repeat(24)+walletAddress.slice(2).toLowerCase(),
                    '0'.repeat(24)+contractAddress.slice(2).toLowerCase(),
                    '0'.repeat(61)+'160',
                    '0'.repeat(61)+'220',
                    zero,
                    '0'.repeat(64-startTimeBigInt.length)+startTimeBigInt,
                    '0'.repeat(64-endTimeBigInt.length)+endTimeBigInt,
                    zero,
                    '0'.repeat(64-saltBigInt.length)+saltBigInt,
                    zero,
                    one,
                    one,
                    '0'.repeat(63)+'2',
                    '0'.repeat(24)+tokenAddress.slice(2).toLowerCase(),
                    '0'.repeat(64-tokenIdBigInt.length)+tokenIdBigInt,
                    one,
                    one,
                    one,
                    zero,
                    zero,
                    zero,
                    '0'.repeat(64-priceWeiBigInt.length)+priceWeiBigInt,
                    '0'.repeat(64-priceWeiBigInt.length)+priceWeiBigInt,
                    '0'.repeat(24)+walletAddress.slice(2).toLowerCase(),
                    '0'.repeat(62)+'41'+signature.slice(2)+'0'.repeat(62)
                ]

                // Join the calldata segments
                const calldata = calldataSegments.join('');

                // Send the transaction
                request('eth_sendTransaction', [{ from: walletAddress, to: contractAddress, data: calldata }]);
            }

            // Function triggered when the 'Buy' button on an item tile is pressed
            function buy(amount,token,tokenId,recipient) {

                const walletAddress = getHtml('walletAddress').textContent;

                // Compose calldata
                const calldataSegments = [
                    '0xdb61c76e',
                    '0'.repeat(64-token.length)+token,
                    tokenId,
                    '0'.repeat(64-recipient.length)+recipient
                ]

                // Join calldata segments
                const calldata = calldataSegments.join('');

                // Send the transaction
                request('eth_sendTransaction', [{ from: walletAddress, to: contractAddress, value: amount, data: calldata }]);
            }

            function cancel() {
                const walletAddress = getHtml('walletAddress').textContent;
                const tokenAddress = getHtml('tokenAddress').value;
                const tokenIdBigInt = toHex(getHtml('tokenIdCancel').value);

                // Compose calldata
                const calldataSegments = [
                    '0x6a206137',
                    '0'.repeat(24)+tokenAddress.slice(2).toLowerCase(),
                    '0'.repeat(64-tokenIdBigInt.length)+tokenIdBigInt
                ]

                // Join calldata segments
                const calldata = calldataSegments.join('');

                // Send the transaction
                request('eth_sendTransaction', [{ from: walletAddress, to: contractAddress, data: calldata }]);         
            }
        
        </script>
    </head>
    <body>
        <div>
            <h1>Onchain Marketplace v0.0.2</h1>
            <p style='font-weight: bold;'>An onchain frontend and database for ERC721 trading on top of Seaport Protocol.</p>
            <p>⚠️Onchain Marketplace is in alpha, do not interact with the contract with any valuable wallets or NFTs and only use on Goerli testnet⚠️</p>
        </div>
        <div>
            <span id='welcome'>Welcome!</span><span id='walletAddress'></span>
            <p>Start by typing the address of the collection you would like to buy or sell from in the box below (defaults to the Terraform Automata Goerli collection) and connect your wallet with the 'Load Collection' button (make sure to be on the Goerli network). All content is loaded via RPC requests sent to your wallet provider.</p>
            <input type='text' id='tokenAddress' name='tokenAddress' value='0xa29926934846fbf1000b5bce7a309a89dfb6f05a' />
            <button onclick='connect()'>Load Collection</button>
        </div>
        <h2 id='network'></h2>
        <div id='forSale' style='display: flex; flex-wrap: wrap;'></div>
        <div style='display: none;' id='sell'>
            <h3 style='margin-top: 5vh; margin-bottom: 0.5vh;'>Sell an item from this collection</h3>
            <input type='number' id='tokenId' placeholder='token id'/>
            <input type='number' id='price' placeholder='price (eth)'/>
            <input type='number' id='duration' placeholder='duration (days)'/>
            <button onclick='sell()' class='sell'>Sell</button>
            <h3 style='margin-top: 5vh; margin-bottom: 0.5vh;'>Cancel a sale from this collection</h3>
            <input type='number' id='tokenIdCancel' placeholder='token id'/>  
            <button onclick='cancel()' class='sell'>Cancel</button>
            <h3 style='margin-top: 5vh; margin-bottom: 0.5vh;'>Further information</h3>
            <p style='font-weight: bold;'>Buy and cancel orders can be approved directly with one simple wallet transaction. Sell orders however require a few more steps:</p>
            <ul>
                <li><span style='font-weight: bold;'>Give Seaport access to your NFT: </span> If you haven't approved this NFT for sale previously, you will be asked to give the Seaport contract access to it (0x00000000000001ad428e4906aE43D8F9852d0dD6). This is the same procedure as approving a collection for the first time on Opensea, with the added safety of only approving one specific NFT from the collection.</li>
                <li><span style='font-weight: bold;'>Sign your sell order: </span> Next, you will be asked to sign your sell order. Your wallet will show you the parameters of the order before signing. This is required for each sale, and functions the same on Opensea.</li>
                <li><span style='font-weight: bold;'>Save the order in the Onchain Marketplace database: </span> One final step is required to store your sell order in the Onchain Marketplace storage, this is the last transaction that will appear on your screen. Marketplaces such as Opensea don't require this step as they store your order off-chain.</li>
            </ul>
        </div>
    </body>
</html>